(*
kGameObject
===========

The kGameObject file holds all functions and procedures
necessary for interacting with RS3 interactable game
objects. (trees / ores / NPCs / etc.)

*)

{$include_once SRL-6-SIMBA1.2/SRL.simba}
{$include_once NAS/NAS.simba}
{$f-}

(*
**type kGameObject**

A type that stores the game object settings properties.

*)
type
  kGameObject = record
    name          : string;
    overText      : TStringArray;
    chooseOption  : string;
    size          : array[0..1] of integer;
    gePrice       : integer;
    skill         : string;
    XP            : integer;
    respawnTime   : integer;
    colTimeout    : integer;
  end;

(*
**type kMonster**

A Type that stores cols/gameObject settings for monsters.

*)
type
  kMonster = record
    constXP       : integer;
    level         : integer;
    color         : TColorData;
  end;

(*
**var kMonster**

A variable through which scripters can access the kMonster methods.

*)
//var
  //Chicken, Cow: kMonster;

(*
**type kTree**

A type that stores the cols/gameObject settings for trees.

*)
type
  kTree = record
    tree_col: TColorData;           //color of uncut tree
    bottom_col: TColorData;           //color of bottom edge
    cut_col: TColorData;            //color of top of trunk after tree is cut
    settings: kGameObject;          //gameobject settings
  end;

(*
**var kTree**

A variable through which scripters can access the kTree methods.

*)
var
  Tree, Oak, Willow, Teak, Maple, Mahogany, Yew, Magic, Cursed_Magic, Elder, Crystal: kTree;

(*
**type kOre**

A type that stores the cols/gameObject settings for ores.

*)
type
  kOre = record
    rock_col: TColorData;           //col of rocks
    ore_col: TColorData;            //col of specific ore
    settings: kGameObject;          //gameobject settings
  end;

(*
**var kOre**

A variable through which scripters can access the kOre methods.

*)
var
  Copper, Tin, Iron, Silver, Gold, Coal, Mithril, Adamantite, Runite: kOre;

(*
**type kWisp**

A type that stores the cols/gameObject settings for wisps.

*)
type
  kWisp = record
    col: TColorData;
    settings: kGameObject;
  end;

(*
**var kWisp**

A variable through which scripters can access the kWisp methods.

*)
var
  Pale: kWisp;

(*
getPrice
--------

    function getPrice(): integer;

Returns the Grand Exchange price of an item found on RS3-Wikia

.. note::

    - by Klamor
    - Last Updated: 19 December 2017

Example:

      writeln('Soft Clay Price: ', getPrice('Soft_Clay'));

*)
function getPrice(s: string):integer

var thePage, thePrice:string;

begin
  thePage := getPage('runescape.wikia.com/wiki/Exchange:' + s);
  thePrice := between('GEPrice">', '</span>', thePage);
  thePrice := replace(thePrice, ',', '', [rfReplaceAll]);
  result := strToIntDef(thePrice, 0);
end;

(*
kTree methods
~~~~~~~~~~~~~

The following methods should be called through the various kTree variables.

Example:

    writeLn('Willow XP: ', totr(Willow.settings.xp));
*)

{*
init
------

    procedure kTree.init(_tree_col, _leaf_col, _cut_col: TColorData; _settings: kGameObject);

Initializes a kTree object.

.. note::

    - by Klamor
    - Last Updated: 19 December 2017

Example:

    Tree.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Tree', ['Tree'], 'hop', [50. 100], getPrice('Logs'), 'Woodcutting', 25, 60000, 30000]);

*}
procedure kTree.init(_tree_col, _bottom_col, _cut_col: TColorData; _settings: kGameObject);
begin
  self.tree_col := _tree_col;
  self.bottom_col := _bottom_col;
  self.cut_col := _cut_col;
  self.settings := _settings;
end;

(*
initTrees
---------

    procedure initTrees();

Initializes known tree objects.

.. note::

    - by Klamor
    - Last Updated: 19 December 2017

Example:

      initTrees();

*)
procedure initTrees();
begin
  //TREEOBJECT.INIT([TREE_COL], [BOTTOM_COL], [CUT_COL], ['NAME', ['OVER','TEXT'], 'CHOOSEOPTION', ])
  Tree.init([4821171, 18, [2, [0.07, 0.90, 0.00]]], [3092775, 4, [2, [1.02, 1.21, 0.00]]], [11709110, 8, [2, [1.85, 0.37, 0.00]]], ['Tree', ['Tree'], 'hop down', [50, 100], getPrice('Logs'), 'Woodcutting', 25, 60000, 30000]);
  Oak.init([5005148, 12, [2, [0.59, 0.49, 0.00]]], [3555643, 10, [2, [1.17, 0.32, 0.00]]], [12435401, 0, [2, [0.00, 0.00, 0.00]]], ['Oak Tree', ['Oak'], 'hop down', [50, 100], getPrice('Oak_Logs'), 'Woodcutting', round(37.5), 60000, 30000]);
  Willow.init([1057287, 6, [2, [0.32, 5.90, 0.00]]], [1319176, 5, [2, [0.28, 5.97, 0.00]]], [4149804, 3, [2, [0.16, 0.39, 0.00]]], ['Willow Tree', ['Willow'], 'hop down', [50, 100], getPrice('Willow_Logs'), 'Woodcutting', round(67.5), 60000, 30000]);
  Teak.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Teak Tree', ['Teak'], 'hop down', [50, 100], getPrice('Teak_Logs'), 'Woodcutting', 85, 60000, 30000]);
  Maple.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Maple Tree', ['Maple'], 'hop down', [50, 100], getPrice('Maple_Logs'), 'Woodcutting', 100, 60000, 30000]);
  Mahogany.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Mahogany Tree', ['Mahogany'], 'hop down', [50, 100], getPrice('Mahogany_Logs'), 'Woodcutting', 125, 60000, 30000]);
  Yew.init([3957886, 10, [2, [0.05, 0.13, 0.00]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Yew Tree', ['Yew'], 'hop down', [50, 100], getPrice('Yew_Logs'), 'Woodcutting', 175, 60000, 30000]);
  Magic.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Magic Tree', ['Magic'], 'hop down', [50, 100], getPrice('Magic_Logs'), 'Woodcutting', 250, 60000, 30000]);
  Cursed_Magic.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Cursed Magic Tree', ['Cursed'], 'hop down', [50, 100], getPrice('Cursed_Magic_Logs'), 'Woodcutting', 275, 60000, 30000]);
  Elder.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Elder Tree', ['Elder'], 'hop down', [50, 100], getPrice('Elder_Logs'), 'Woodcutting', 325, 60000, 30000]);
  Crystal.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Cyrstal Tree', ['Crystal'], 'hop down', [50, 100], getPrice('Crystal_Logs'), 'Woodcutting', round(434.5), 60000, 30000]);
end;

(*
kTree.findTree()
----------------

    procedure kTree.findTree(hoverNext: Boolean = false): Boolean;

Returns true if we successfully find and click a tree on the mainscreen.

.. note::

    - by Klamor
    - Last Updated: 21 December 2017

Example:

      if Willow.findTree() then
        writeLn('Found: ', Willow.settings.name, '!');

*)
function kTree.findTree(hoverNext: Boolean = false): Boolean;
var
  treeATPA, good, bad, TPAs: T2DPointArray;
  i, x, y: Integer;
  searchBox: TBox;
begin
  setLength(TPAs, 3);
  searchBox := [mainScreen.playerBox.X1 - 500, mainScreen.playerBox.Y1 - 300, mainScreen.playerBox.X2 + 500, mainScreen.playerBox.Y2 + 300];

  {$IFDEF NAS_DRAWING}
    NAS.Drawing.drawBox(searchBox, false, clBlue);
  {$ENDIF}

  self.tree_col.gatherIn(TPAs[0], searchBox);
  self.bottom_col.gatherIn(TPAs[1], searchBox);
  self.cut_col.gatherIn(TPAs[2], searchBox);

  treeATPA := TPAs[0].toATPA(25, 25);

  for i := 0 to high(treeATPA) do
  begin
    if treeATPA[i].isPointNear(middleTPA(TPAs[2]), 50) then
    begin
      setLength(bad, (high(bad) + 1));
      bad := bad + treeATPA[i];
      break;
    end;
    if treeATPA[i].isPointNear(middleTPA(TPAs[1]), 75) then
    begin
      setLength(good, (high(good) + 1));
      good := good + treeATPA[i];
    end;
  end;

  good.sortFromMidPoint(mainscreen.playerPoint);

  for i := 0 to high(good) do
  begin
    mouse(good[i].getBounds().getGaussPoint());
    if isMouseOverText(self.settings.overText) then
      if hoverNext then
        exit(true)
      else if (random(4) <> 0) then          // 75% chance of left click
        begin
          getMousePos(x, y);
          result := multiClick([x, y], 15, 3); // If left click, 15% chance to multi-click
          smallRandomMouse();
          break();
        end else
        begin
          fastClick(MOUSE_RIGHT);
          if chooseOption.select([self.settings.chooseOption]) then
          begin
            smallRandomMouse();
            exit(true);
          end;
        end;
  end;
end;

(*
kTree.chopDone()
----------------

    procedure kTree.chopDone(): Boolean;

Returns true if we are done cutting a tree.

.. note::

    - by Klamor
    - Last Updated: 22 December 2017
    - Inspired by Coh3n's Chop_Finished() in Draynor Chop N' Bank

Example:

      if Willow.chopDone() then
        writeLn('Done cutting: ', Willow.settings.name, '!');

*)
function kTree.chopDone(): boolean;
var
  timeout: TTimeMarker;
  avg, max, done: Integer;
  txtPoint: TPoint;
begin
  if not isLoggedIn() then
    exit;

  max := (self.settings.colTimeout + randomRange(-10000, 10000));

  txtPoint := point(mainScreen.playerPoint.X - 50, mainScreen.playerPoint.Y + 50);

  done := 0;

  timeout.reset();
  timeout.start();

  repeat
    avg := getPixelShiftAverage(mainscreen.playerBox, 100, 300);

    {$IFDEF NAS_DRAWING}
      NAS.Drawing.drawBox(mainscreen.playerBox, false, clRed);
      NAS.Drawing.drawText(self.settings.name + '.chopDone(): ' + intToStr(avg), txtPoint, 'SmallChars07', false, clWhite);
      NAS.Drawing.clear();
    {$ENDIF}

    if (inRange(avg, 0, 600)) then
    begin
      Inc(done);

      if (done = 1) then
        Continue;
    end else
      done := 0;

    if (done >= 2) or (tabBackpack.isFull()) then
    begin
      Result := True;
      {$IFDEF NAS_DRAWING}
        NAS.Drawing.drawBox(mainscreen.playerBox, false, clRed);
        NAS.Drawing.drawText(self.settings.name + '.chopDone(): ' + toStr(result), txtPoint, 'SmallChars07', false, clWhite);
        NAS.Drawing.clear();
      {$ENDIF}
      Break;
    end;

  until (timeout.getTime() > max) or (not isLoggedIn());
end;

(*
kOre methods
~~~~~~~~~~~~

The following methods should be called through the various kOre variables.

Example:

    writeLn('Copper XP: ', totr(Copper.settings.xp));
*)

{*
init
------

    procedure kOre.init(_rock_col, _ore_col: TColorData; _settings: kGameObject);

Initializes a kOre object.

.. note::

    - by Klamor
    - Last Updated: 19 December 2017

Example:

     Copper.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Copper Rocks', ['Copper', 'Ore'], 'mine', [25. 25], getPrice('Copper_Ore'), 'Mining', round(17.5), 60000, 30000]);

*}
procedure kOre.init(_rock_col, _ore_col: TColorData; _settings: kGameObject);
begin
  self.rock_col := _rock_col;
  self.ore_col := _ore_col;
  self.settings := _settings;
end;

(*
initOres
--------

    procedure initOres();

Initializes known ore objects.

.. note::

    - by Klamor
    - Last Updated: 19 December 2017

Example:

      initOres();

*)

procedure initOres();
begin
  Copper.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Copper Rocks', ['Copper', 'Ore'], 'mine', [25, 25], getPrice('Copper_Ore'), 'Mining', round(17.5), 60000, 30000]);
  Tin.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Tin Rocks', ['Tin', 'ore'], 'mine', [25, 25], getPrice('Tin_ore'), 'Mining', round(17.5), 60000, 30000]);
  Iron.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Iron Rocks', ['Iron', 'ore'], 'mine', [25, 25], getPrice('Iron_ore'), 'Mining', 35, 60000, 30000]);
  Silver.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Silver Rocks', ['Silver', 'ore'], 'mine', [25, 25], getPrice('Silver_ore'), 'Mining', 40, 60000, 30000]);
  Coal.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Coal Rocks', ['Coal', 'rocks'], 'mine', [25, 25], getPrice('Coal'), 'Mining', 50, 60000, 30000]);
  Gold.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Gold Rocks', ['Gold', 'ore'], 'mine', [25, 25], getPrice('Gold_ore'), 'Mining', 65, 60000, 30000]);
  Mithril.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Mithril Rocks', ['Mithril', 'ore'], 'mine', [25, 25], getPrice('Mithril_ore'), 'Mining', 80, 60000, 30000]);
  Adamantite.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Adamantite Rocks', ['Adamantite', 'ore'], 'mine', [25, 25], getPrice('Adamantite_ore'), 'Mining', 95, 60000, 30000]);
  Runite.init([0, 0, [0, [0, 0, 0]]], [0, 0, [0, [0, 0, 0]]], ['Runite Rocks', ['Runite', 'ore'], 'mine', [25, 25], getPrice('Runite_ore'), 'Mining', 125, 60000, 30000]);
end;

(*
kWisp methods
~~~~~~~~~~~~~

The following methods should be called through the various kWisp variables.

Example:

    write something here
*)

{*
init
------

    procedure kWisp.init(_glow_col, _wisp_col: TColorData; level_req: Integer; _settings: kGameObject);

Initializes a kWisp object.

.. note::

    - by Klamor
    - Last Updated: 26 December 2017

Example:

    write soemthing here

*}
procedure kWisp.init(_col: TColorData; _settings: kGameObject);
begin
  self.col := _col;
  self.settings := _settings;
end;

(*
initWisps
---------

    procedure initWisps();

Initializes known wisp objects.

.. note::

    - by Klamor
    - Last Updated: 26 December 2017

Example:

      initWisps();

*)
procedure initWisps();
begin
  Pale.init([13150361, 11, [2, [0.20, 0.67, 0.00]]], ['Pale Wisp', ['arvest', 'Pale', 'Wisp'], 'arvest', [15,15], getPrice('Pale_energy'), 'Divination', 0, 30000, 30000]);
end;

(*
kWisp.findWisps()
----------------

    function kWisp.findWisps(hoverNext: Boolean = false): Boolean;

Returns true if we successfully find and click a wisp on the mainscreen.

.. note::

    - by Klamor
    - Last Updated: 21 December 2017

Example:

      if Pale.findWisps(false) then
        writeLn('Found: ', Pale.settings.name, '!');

*)
function kWisp.findWisps(hoverNext: Boolean = false): Boolean;
var
  TPA: TPointArray;
  wisps: T2DPointArray;
  i, x, y: Integer;
  searchBox: TBox;
begin
  searchBox := [mainScreen.playerBox.X1 - 600, mainScreen.playerBox.Y1 - 400, mainScreen.playerBox.X2 + 600, mainScreen.playerBox.Y2 + 400];

  {$IFDEF NAS_DRAWING}
    NAS.Drawing.drawBox(searchBox, false, clBlue);      //remove later if it's a good search area
  {$ENDIF}

  self.col.gatherIn(TPA, searchBox);
  wisps := TPA.toATPA(5, 5);
  wisps.sortFromMidPoint(mainScreen.playerPoint);

  for x := 0 to high(wisps) do
  begin
    {$IFDEF NAS_DRAWING}
      NAS.Drawing.debugTPA(wisps[x]);
    {$ENDIF}
    mouse(wisps[x].getBounds().getGaussPoint());
    if isMouseOverText(self.settings.overText) then
      if hoverNext then
      begin
        exit(true)
      end else if (random(4) <> 0) then          // 75% chance of left click
        begin
          getMousePos(x, y);
          result := multiClick([x, y], 15, 3); // If left click, 15% chance to multi-click
          smallRandomMouse();
          break();
        end else
        begin
          fastClick(MOUSE_RIGHT);
          if chooseOption.select([self.settings.chooseOption]) then
          begin
            smallRandomMouse();
            exit(true);
          end;
        end;
  end;
end;

(*
kWisp.doneHarvesting()
----------------

    procedure kWisp.doneHarvesting(): boolean;

Returns true if we are done cutting a tree.

.. note::

    - by Klamor
    - Last Updated: 22 December 2017
    - Inspired by Coh3n's Chop_Finished() in Draynor Chop N' Bank

Example:

      if Pale.doneHarvesting() then
        writeLn('Done harvesting: ', Pale.settings.name, '!');

*)
function kWisp.doneHarvesting(): boolean;
var
  harvestTimer: TTimeMarker;
  txtPoint: TPoint;
  avg, timeout, done: Integer;
begin
  if not isLoggedIn() then
    exit;

  txtPoint := point(mainScreen.playerPoint.X - 75, mainScreen.playerPoint.Y + 50);    //debug text location

  timeout := (25000 + random(15000)); //timeout after random(25-40) seconds

  done := 0;

  harvestTimer.reset();
  harvestTimer.start();

  repeat
    avg := getPixelShiftAverage(mainscreen.playerBox, 100, 300);

    {$IFDEF NAS_DRAWING}
      NAS.Drawing.drawBox(mainscreen.playerBox, false, clRed);
      NAS.Drawing.drawText(self.settings.name + '.doneHarvesting(): ' + intToStr(avg), txtPoint, 'SmallChars07', false, clWhite);
      NAS.Drawing.clear();
    {$ENDIF}

    if (inRange(avg, 0, 600)) then
    begin
      Inc(done);

      if (done = 1) then
        Continue;
    end else
      done := 0;

    if (done >= 2) or (tabBackpack.isFull()) then
    begin
      Result := True;
      {$IFDEF NAS_DRAWING}
        NAS.Drawing.drawBox(mainscreen.playerBox, false, clRed);
        NAS.Drawing.drawText(self.settings.name + '.doneHarvesting(): ' + toStr(result), txtPoint, 'SmallChars07', false, clWhite);
        NAS.Drawing.clear();
      {$ENDIF}
      Break;
    end;

  until (harvestTimer.getTime() > timeout) or (not isLoggedIn());
end;

function kWisp.findRift(hoverNext: Boolean = false): Boolean;
begin

end;

(*
kWisp.isConverting()
----------------

    function kWisp.isConverting(): boolean;

Returns true if we are still converting memories.

.. note::

    - by Klamor
    - Last Updated: 22 December 2017
    - Inspired by Coh3n's Chop_Finished() in Draynor Chop N' Bank

Example:

      if Pale.doneHarvesting() then
        writeLn('Done harvesting: ', Pale.settings.name, '!');

*)
function kWisp.isConverting(): boolean;
begin

end;
(*
kWisp.convertMemories()
----------------

    procedure kWisp.convertMemories(select: Integer);

Converts memories to (select: Integer)*1..3* type.
1: to Energy
2: to EXP
3: to Enhanced EXP

.. note::

    - by Klamor
    - Last Updated: 22 December 2017

Example:

      if Pale.convertMemories() then
        writeLn('Converted all memories to: ', toStr(select), '!');

*)
procedure kWisp.convertMemories(select: Integer);
begin

end;

begin
  initTrees();
  initOres();
  initWisps();
end;
